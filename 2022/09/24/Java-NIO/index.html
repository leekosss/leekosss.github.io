

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/leekos.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="leekos">
  <meta name="keywords" content="">
  
    <meta name="description" content="现在使用NIO的场景越来越多，很多网上的技术框架或多或少的使用NIO技术，譬如Tomcat，Jetty。学习和掌握NIO技术已经不是一个JAVA攻城狮的加分技能，而是一个必备技能。在前面2篇文章《什么是Zero-Copy?》和《NIO相关基础篇》中我们学习了NIO的相关理论知识，而在本篇中我们一起来学习一下Java NIO的实战知识。全文较长，建议先马后看（记得关注不迷路）。 一、概述NIO主要有">
<meta property="og:type" content="article">
<meta property="og:title" content="Java NIO">
<meta property="og:url" content="https://leekosss.github.io/2022/09/24/Java-NIO/index.html">
<meta property="og:site_name" content="Tranquility">
<meta property="og:description" content="现在使用NIO的场景越来越多，很多网上的技术框架或多或少的使用NIO技术，譬如Tomcat，Jetty。学习和掌握NIO技术已经不是一个JAVA攻城狮的加分技能，而是一个必备技能。在前面2篇文章《什么是Zero-Copy?》和《NIO相关基础篇》中我们学习了NIO的相关理论知识，而在本篇中我们一起来学习一下Java NIO的实战知识。全文较长，建议先马后看（记得关注不迷路）。 一、概述NIO主要有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leekosss.github.io/Java-NIO/640">
<meta property="og:image" content="https://leekosss.github.io/Java-NIO/photo.png">
<meta property="og:image" content="https://leekosss.github.io/Java-NIO/photo1.png">
<meta property="og:image" content="https://leekosss.github.io/Java-NIO/photo2.png">
<meta property="article:published_time" content="2022-09-24T10:32:39.000Z">
<meta property="article:modified_time" content="2022-09-24T10:45:49.020Z">
<meta property="article:author" content="leekos">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leekosss.github.io/Java-NIO/640">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java NIO - Tranquility</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leekosss.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tranquility</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java NIO"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-24 18:32" pubdate>
          2022年9月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          201 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java NIO</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年9月24日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>现在使用NIO的场景越来越多，很多网上的技术框架或多或少的使用NIO技术，譬如Tomcat，Jetty。学习和掌握NIO技术已经不是一个JAVA攻城狮的加分技能，而是一个必备技能。在前面2篇文章《<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483913&idx=1&sn=2da53737b8e8908cf3efdae9621c9698&chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&scene=21#wechat_redirect">什么是Zero-Copy?</a>》和《<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483907&idx=1&sn=3d5e1384a36bd59f5fd14135067af1c2&chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&scene=21#wechat_redirect">NIO相关基础篇</a>》中我们学习了NIO的相关理论知识，而在本篇中我们一起来学习一下Java NIO的实战知识。全文较长，建议先马后看（记得关注不迷路）。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>
<p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<p>IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream.而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO中的Channel的主要实现有：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>这里看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。下面演示的案例基本上就是围绕这4个类型的Channel进行陈述的。</p>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不进行陈述。</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p>
<h2 id="二、FileChannel"><a href="#二、FileChannel" class="headerlink" title="二、FileChannel"></a>二、FileChannel</h2><p>看完上面的陈述，对于第一次接触NIO的同学来说云里雾里，只说了一些概念，也没记住什么，更别说怎么用了。这里开始通过传统IO以及更改后的NIO来做对比，以更形象的突出NIO的用法，进而使你对NIO有一点点的了解。</p>
<h3 id="传统IO-vs-NIO"><a href="#传统IO-vs-NIO" class="headerlink" title="传统IO vs NIO"></a>传统IO vs NIO</h3><p>首先，案例1是采用FileInputStream读取文件内容的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span>()</span>&#123;<br>    InputStream <span class="hljs-keyword">in</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/nomal_io.txt&quot;</span>));<br>        <span class="hljs-built_in">byte</span> [] buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">int</span> bytesRead = <span class="hljs-keyword">in</span>.read(buf);<br>        <span class="hljs-keyword">while</span>(bytesRead != <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;bytesRead;i++)<br>                System.<span class="hljs-keyword">out</span>.print((<span class="hljs-built_in">char</span>)buf[i]);<br>            bytesRead = <span class="hljs-keyword">in</span>.read(buf);<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)<br>    &#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">in</span>.close();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：（略）</p>
<p>案例是对应的NIO（这里通过RandomAccessFile进行操作，当然也可以通过FileInputStream.getChannel()进行操作）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span>()</span>&#123;<br>    RandomAccessFile aFile = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        aFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;src/nio.txt&quot;</span>,<span class="hljs-string">&quot;rw&quot;</span>);<br>        FileChannel fileChannel = aFile.getChannel();<br>        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-built_in">int</span> bytesRead = fileChannel.read(buf);<br>        System.<span class="hljs-keyword">out</span>.println(bytesRead);<br>        <span class="hljs-keyword">while</span>(bytesRead != <span class="hljs-number">-1</span>)<br>        &#123;<br>            buf.flip();<br>            <span class="hljs-keyword">while</span>(buf.hasRemaining())<br>            &#123;<br>                System.<span class="hljs-keyword">out</span>.print((<span class="hljs-built_in">char</span>)buf.<span class="hljs-keyword">get</span>());<br>            &#125;<br>            buf.compact();<br>            bytesRead = fileChannel.read(buf);<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(aFile != <span class="hljs-literal">null</span>)&#123;<br>                aFile.close();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：（略）<br>通过仔细对比案例1和案例2，应该能看出个大概，最起码能发现NIO的实现方式比叫复杂。有了一个大概的印象可以进入下一步了。</p>
<h3 id="Buffer的使用"><a href="#Buffer的使用" class="headerlink" title="Buffer的使用"></a>Buffer的使用</h3><p>从案例2中可以总结出使用Buffer一般遵循下面几个步骤：</p>
<ul>
<li>分配空间（ByteBuffer buf &#x3D; ByteBuffer.allocate(1024); 还有一种allocateDirector后面再陈述）</li>
<li>写入数据到Buffer(int bytesRead &#x3D; fileChannel.read(buf);)</li>
<li>调用filp()方法（ buf.flip();）</li>
<li>从Buffer中读取数据（System.out.print((char)buf.get());）</li>
<li>调用clear()方法或者compact()方法</li>
</ul>
<p>Buffer顾名思义：缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。如下图：</p>
<p><img src="/Java-NIO/640" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>向Buffer中写数据：</p>
<ul>
<li>从Channel写到Buffer (fileChannel.read(buf))</li>
<li>通过Buffer的put()方法 （buf.put(…)）</li>
</ul>
<p>从Buffer中读取数据：</p>
<ul>
<li>从Buffer读取到Channel (channel.write(buf))</li>
<li>使用get()方法从Buffer中读取数据 （buf.get()）</li>
</ul>
<p>可以把Buffer简单地理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态：capacity, position, limit, mark：</p>
<table>
<thead>
<tr>
<th><strong>索引</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>缓冲区数组的总长度</td>
</tr>
<tr>
<td>position</td>
<td>下一个要操作的数据元素的位置</td>
</tr>
<tr>
<td>limit</td>
<td>缓冲区数组中不可操作的下一个元素的位置：limit&lt;&#x3D;capacity</td>
</tr>
<tr>
<td>mark</td>
<td>用于记录当前position的前一个位置或者默认是-1</td>
</tr>
</tbody></table>
<p><img src="/Java-NIO/photo.png" srcset="/img/loading.gif" lazyload alt="photo"></p>
<p>无图无真相，举例：我们通过ByteBuffer.allocate(11)方法创建了一个11个byte的数组的缓冲区，初始状态如上图，position的位置为0，capacity和limit默认都是数组长度。当我们写入5个字节时，变化如下图：</p>
<p><img src="/Java-NIO/photo1.png" srcset="/img/loading.gif" lazyload alt="photo1"></p>
<p>这时我们需要将缓冲区中的5个字节数据写入Channel的通信信道，所以我们调用ByteBuffer.flip()方法，变化如下图所示(position设回0，并将limit设成之前的position的值)：</p>
<p><img src="/Java-NIO/photo2.png" srcset="/img/loading.gif" lazyload alt="photo2"></p>
<p>这时底层操作系统就可以从缓冲区中正确读取这个5个字节数据并发送出去了。在下一次写数据之前我们再调用clear()方法，缓冲区的索引位置又回到了初始位置。</p>
<p>调用clear()方法：position将被设回0，limit设置成capacity，换句话说，Buffer被清空了，其实Buffer中的数据并未被清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定的position，之后可以通过调用Buffer.reset()方法恢复到这个position。Buffer.rewind()方法将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素。</p>
<h2 id="三、SocketChannel"><a href="#三、SocketChannel" class="headerlink" title="三、SocketChannel"></a>三、SocketChannel</h2><p>说完了FileChannel和Buffer, 大家应该对Buffer的用法比较了解了，这里使用SocketChannel来继续探讨NIO。NIO的强大功能部分来自于Channel的非阻塞特性，套接字的某些操作可能会无限期地阻塞。例如，对accept()方法的调用可能会因为等待一个客户端连接而阻塞；对read()方法的调用可能会因为没有数据可读而阻塞，直到连接的另一端传来新的数据。总的来说，创建&#x2F;接收连接或读写数据等I&#x2F;O调用，都可能无限期地阻塞等待，直到底层的网络实现发生了什么。慢速的，有损耗的网络，或仅仅是简单的网络故障都可能导致任意时间的延迟。然而不幸的是，在调用一个方法之前无法知道其是否阻塞。NIO的channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现非阻塞式的信道。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">channel.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span><br></code></pre></td></tr></table></figure>

<p>在非阻塞式信道上调用一个方法总是会立即返回。这种调用的返回值指示了所请求的操作完成的程度。例如，在一个非阻塞式ServerSocketChannel上调用accept()方法，如果有连接请求来了，则返回客户端SocketChannel，否则返回null。</p>
<p>这里先举一个TCP应用案例，客户端采用NIO实现，而服务端依旧使用BIO实现。<br>客户端代码（案例3）：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span></span>&#123;<br>    ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">1024</span>);<br>    SocketChannel socketChannel = null;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        socketChannel = SocketChannel.<span class="hljs-built_in">open</span>();<br>        socketChannel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>        socketChannel.<span class="hljs-built_in">connect</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-string">&quot;10.10.195.115&quot;</span>,<span class="hljs-number">8080</span>));<br>        <span class="hljs-keyword">if</span>(socketChannel.<span class="hljs-built_in">finishConnect</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>            &#123;<br>                TimeUnit.SECONDS.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>                <span class="hljs-type">String</span> info = <span class="hljs-string">&quot;I&#x27;m &quot;</span>+i+++<span class="hljs-string">&quot;-th information from client&quot;</span>;<br>                buffer.<span class="hljs-built_in">clear</span>();<br>                buffer.<span class="hljs-built_in">put</span>(info.<span class="hljs-built_in">getBytes</span>());<br>                buffer.<span class="hljs-built_in">flip</span>();<br>                <span class="hljs-keyword">while</span>(buffer.<span class="hljs-built_in">hasRemaining</span>())&#123;<br>                    System.out.<span class="hljs-built_in">println</span>(buffer);<br>                    socketChannel.<span class="hljs-built_in">write</span>(buffer);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (IOException | InterruptedException e)<br>    &#123;<br>        e.<span class="hljs-built_in">printStackTrace</span>();<br>    &#125;<br>    finally&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(socketChannel!=null)&#123;<br>                socketChannel.<span class="hljs-built_in">close</span>();<br>            &#125;<br>        &#125;<span class="hljs-built_in">catch</span>(IOException e)&#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务端代码（案例4）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span>()</span>&#123;<br>    ServerSocket serverSocket = <span class="hljs-literal">null</span>;<br>    InputStream <span class="hljs-keyword">in</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>);<br>        <span class="hljs-built_in">int</span> recvMsgSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">byte</span>[] recvBuf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            Socket clntSocket = serverSocket.accept();<br>            SocketAddress clientAddress = clntSocket.getRemoteSocketAddress();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Handling client at &quot;</span>+clientAddress);<br>            <span class="hljs-keyword">in</span> = clntSocket.getInputStream();<br>            <span class="hljs-keyword">while</span>((recvMsgSize=<span class="hljs-keyword">in</span>.read(recvBuf))!=<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-built_in">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[recvMsgSize];<br>                System.arraycopy(recvBuf, <span class="hljs-number">0</span>, temp, <span class="hljs-number">0</span>, recvMsgSize);<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">new</span> String(temp));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e)<br>    &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(serverSocket!=<span class="hljs-literal">null</span>)&#123;<br>                serverSocket.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">in</span>!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">in</span>.close();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：（略）</p>
<p>根据案例分析，总结一下SocketChannel的用法。<br>打开SocketChannel：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">socketChannel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;10.10.195.115&quot;</span>,8080)</span>);<br></code></pre></td></tr></table></figure>

<p>关闭：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">socketChannel.close()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>读取数据：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span> info = <span class="hljs-string">&quot;I&#x27;m &quot;</span>+i+++<span class="hljs-string">&quot;-th information from client&quot;</span>;<br>buffer.<span class="hljs-built_in">clear</span>();<br>buffer.<span class="hljs-built_in">put</span>(info.<span class="hljs-built_in">getBytes</span>());<br>buffer.<span class="hljs-built_in">flip</span>();<br><span class="hljs-keyword">while</span>(buffer.<span class="hljs-built_in">hasRemaining</span>())&#123;<br>    System.out.<span class="hljs-built_in">println</span>(buffer);<br>    socketChannel.<span class="hljs-built_in">write</span>(buffer);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意SocketChannel.write()方法的调用是在一个while循环中的。write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。<br>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p>
<h2 id="四、TCP服务端的NIO写法"><a href="#四、TCP服务端的NIO写法" class="headerlink" title="四、TCP服务端的NIO写法"></a>四、TCP服务端的NIO写法</h2><p>到目前为止，所举的案例中都没有涉及Selector。不要急，好东西要慢慢来。Selector类可以用于避免使用阻塞式客户端中很浪费资源的“忙等”方法。例如，考虑一个IM服务器。像QQ或者旺旺这样的，可能有几万甚至几千万个客户端同时连接到了服务器，但在任何时刻都只是非常少量的消息。</p>
<p>需要读取和分发。这就需要一种方法阻塞等待，直到至少有一个信道可以进行I&#x2F;O操作，并指出是哪个信道。NIO的选择器就实现了这样的功能。一个Selector实例可以同时检查一组信道的I&#x2F;O状态。用专业术语来说，选择器就是一个多路开关选择器，因为一个选择器能够管理多个信道上的I&#x2F;O操作。然而如果用传统的方式来处理这么多客户端，使用的方法是循环地一个一个地去检查所有的客户端是否有I&#x2F;O操作，如果当前客户端有I&#x2F;O操作，则可能把当前客户端扔给一个线程池去处理，如果没有I&#x2F;O操作则进行下一个轮询，当所有的客户端都轮询过了又接着从头开始轮询；这种方法是非常笨而且也非常浪费资源，因为大部分客户端是没有I&#x2F;O操作，我们也要去检查；而Selector就不一样了，它在内部可以同时管理多个I&#x2F;O，当一个信道有I&#x2F;O操作的时候，他会通知Selector，Selector就是记住这个信道有I&#x2F;O操作，并且知道是何种I&#x2F;O操作，是读呢？是写呢？还是接受新的连接；所以如果使用Selector，它返回的结果只有两种结果，一种是0，即在你调用的时刻没有任何客户端需要I&#x2F;O操作，另一种结果是一组需要I&#x2F;O操作的客户端，这时你就根本不需要再检查了，因为它返回给你的肯定是你想要的。这样一种通知的方式比那种主动轮询的方式要高效得多！</p>
<p>要使用选择器（Selector），需要创建一个Selector实例（使用静态工厂方法open()）并将其注册（register）到想要监控的信道上（注意，这要通过channel的方法实现，而不是使用selector的方法）。最后，调用选择器的select()方法。该方法会阻塞等待，直到有一个或更多的信道准备好了I&#x2F;O操作或等待超时。select()方法将返回可进行I&#x2F;O操作的信道数量。现在，在一个单独的线程中，通过调用select()方法就能检查多个信道是否准备好进行I&#x2F;O操作。如果经过一段时间后仍然没有信道准备好，select()方法就会返回0，并允许程序继续执行其他任务。</p>
<p>下面将上面的TCP服务端代码改写成NIO的方式（案例5）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConnect</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> BUF_SIZE=<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIMEOUT</span> <span class="hljs-operator">=</span> <span class="hljs-number">3000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        selector();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleAccept</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> (ServerSocketChannel)key.channel();<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssChannel.accept();<br>        sc.configureBlocking(<span class="hljs-literal">false</span>);<br>        sc.register(key.selector(), SelectionKey.OP_READ,ByteBuffer.allocateDirect(BUF_SIZE));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRead</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel)key.channel();<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuffer)key.attachment();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> sc.read(buf);<br>        <span class="hljs-keyword">while</span>(bytesRead&gt;<span class="hljs-number">0</span>)&#123;<br>            buf.flip();<br>            <span class="hljs-keyword">while</span>(buf.hasRemaining())&#123;<br>                System.out.print((<span class="hljs-type">char</span>)buf.get());<br>            &#125;<br>            System.out.println();<br>            buf.clear();<br>            bytesRead = sc.read(buf);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bytesRead == -<span class="hljs-number">1</span>)&#123;<br>            sc.close();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleWrite</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuffer)key.attachment();<br>        buf.flip();<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>        <span class="hljs-keyword">while</span>(buf.hasRemaining())&#123;<br>            sc.write(buf);<br>        &#125;<br>        buf.compact();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selector</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            selector = Selector.open();<br>            ssc= ServerSocketChannel.open();<br>            ssc.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(PORT));<br>            ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>            ssc.register(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span>(selector.select(TIMEOUT) == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;==&quot;</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>                <span class="hljs-keyword">while</span>(iter.hasNext())&#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                    <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>                        handleAccept(key);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(key.isReadable())&#123;<br>                        handleRead(key);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;<br>                        handleWrite(key);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(key.isConnectable())&#123;<br>                        System.out.println(<span class="hljs-string">&quot;isConnectable = true&quot;</span>);<br>                    &#125;<br>                    iter.remove();<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">if</span>(selector!=<span class="hljs-literal">null</span>)&#123;<br>                    selector.close();<br>                &#125;<br>                <span class="hljs-keyword">if</span>(ssc!=<span class="hljs-literal">null</span>)&#123;<br>                    ssc.close();<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面来慢慢讲解这段代码。</p>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>打开ServerSocketChannel：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ServerSocketChannel serverSocketChannel <span class="hljs-operator">=</span> ServerSocketChannel.open()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>关闭ServerSocketChannel：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">serverSocketChannel.close()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>监听新进来的连接：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    SocketChannel socketChannel = serverSocketChannel.<span class="hljs-keyword">accept</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ServerSocketChannel serverSocketChannel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>serverSocketChannel.socket<span class="hljs-literal">()</span>.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(9999)</span>);<br>serverSocketChannel.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>    SocketChannel socketChannel = serverSocketChannel.accept<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (socketChannel != null)<br>    &#123;<br>        <span class="hljs-comment">// do something with socketChannel...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h3><p>Selector的创建：Selector selector &#x3D; Selector.open();</p>
<p>为了将Channel和Selector配合使用，必须将Channel注册到Selector上，通过SelectableChannel.register()方法来实现，沿用案例5中的部分代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ssc= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>ssc.socket<span class="hljs-literal">()</span>.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(PORT)</span>);<br>ssc.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>ssc.register(selector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure>

<p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>
<p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> Connect<br><span class="hljs-bullet">2.</span> Accept<br><span class="hljs-bullet">3.</span> Read<br><span class="hljs-bullet">4.</span> Write<br></code></pre></td></tr></table></figure>

<p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p>
<p>这四种事件用SelectionKey的四个常量来表示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>. SelectionKey<span class="hljs-selector-class">.OP_CONNECT</span><br><span class="hljs-number">2</span>. SelectionKey<span class="hljs-selector-class">.OP_ACCEPT</span><br><span class="hljs-number">3</span>. SelectionKey<span class="hljs-selector-class">.OP_READ</span><br><span class="hljs-number">4</span>. SelectionKey.OP_WRITE<br></code></pre></td></tr></table></figure>

<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象（可选）</li>
</ul>
<p>interest集合：就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合。</p>
<p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int readySet <span class="hljs-operator">=</span> selectionKey.readyOps()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">selectionKey.isAcceptable()<span class="hljs-comment">;</span><br>selectionKey.isConnectable()<span class="hljs-comment">;</span><br>selectionKey.isReadable()<span class="hljs-comment">;</span><br>selectionKey.isWritable()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>从SelectionKey访问Channel和Selector很简单。如下：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Channel  channel  <span class="hljs-operator">=</span> selectionKey.channel()<span class="hljs-comment">;</span><br>Selector selector <span class="hljs-operator">=</span> selectionKey.selector()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">selectionKey.attach(theObject)<span class="hljs-comment">;</span><br>Object attachedObj <span class="hljs-operator">=</span> selectionKey.attachment()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">SelectionKey key = channel.<span class="hljs-keyword">register</span>(selector, SelectionKey.OP_READ, theObject);<br></code></pre></td></tr></table></figure>

<h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p>
<p>下面是select()方法：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p>select()阻塞到至少有一个通道在你注册的事件上就绪了。<br>select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。<br>selectNow()不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。</p>
<p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Set selectedKeys <span class="hljs-operator">=</span> selector.selectedKeys()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>当向Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。</p>
<p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p>
<p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p>
<p>一个完整的使用Selector和ServerSocketChannel的案例可以参考案例5的selector()方法。</p>
<hr>
<h2 id="五、内存映射文件"><a href="#五、内存映射文件" class="headerlink" title="五、内存映射文件"></a>五、内存映射文件</h2><p>JAVA处理大文件，一般用BufferedReader,BufferedInputStream这类带缓冲的IO类，不过如果文件超大的话，更快的方式是采用MappedByteBuffer。</p>
<p>MappedByteBuffer是NIO引入的文件内存映射方案，读写性能极高。NIO最主要的就是实现了对异步操作的支持。其中一种通过把一个套接字通道(SocketChannel)注册到一个选择器(Selector)中,不时调用后者的选择(select)方法就能返回满足的选择键(SelectionKey),键中包含了SOCKET事件信息。这就是select模型。</p>
<p>SocketChannel的读写是通过一个类叫ByteBuffer来操作的.这个类本身的设计是不错的,比直接操作byte[]方便多了. ByteBuffer有两种模式:直接&#x2F;间接.间接模式最典型(也只有这么一种)的就是HeapByteBuffer,即操作堆内存 (byte[]).但是内存毕竟有限,如果我要发送一个1G的文件怎么办?不可能真的去分配1G的内存.这时就必须使用”直接”模式,即 MappedByteBuffer,文件映射.</p>
<p>先中断一下,谈谈操作系统的内存管理.一般操作系统的内存分两部分:物理内存;虚拟内存.虚拟内存一般使用的是页面映像文件,即硬盘中的某个(某些)特殊的文件.操作系统负责页面文件内容的读写,这个过程叫”页面中断&#x2F;切换”. MappedByteBuffer也是类似的,你可以把整个文件(不管文件有多大)看成是一个ByteBuffer.MappedByteBuffer 只是一种特殊的ByteBuffer，即是ByteBuffer的子类。 MappedByteBuffer 将文件直接映射到内存（这里的内存指的是虚拟内存，并不是物理内存）。通常，可以映射整个文件，如果文件比较大的话可以分段进行映射，只要指定文件的那个部分就可以。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>FileChannel提供了map方法来把文件影射为内存映像文件： MappedByteBuffer map(int mode,long position,long size); 可以把文件的从position开始的size大小的区域映射为内存映像文件，mode指出了 可访问该内存映像文件的方式：</p>
<ul>
<li>READ_ONLY,（只读）： 试图修改得到的缓冲区将导致抛出 ReadOnlyBufferException.(MapMode.READ_ONLY)</li>
<li>READ_WRITE（读&#x2F;写）： 对得到的缓冲区的更改最终将传播到文件；该更改对映射到同一文件的其他程序不一定是可见的。 (MapMode.READ_WRITE)</li>
<li>PRIVATE（专用）： 对得到的缓冲区的更改不会传播到文件，并且该更改对映射到同一文件的其他程序也不是可见的；相反，会创建缓冲区已修改部分的专用副本。 (MapMode.PRIVATE)</li>
</ul>
<p>MappedByteBuffer是ByteBuffer的子类，其扩充了三个方法：</p>
<ul>
<li>force()：缓冲区是READ_WRITE模式下，此方法对缓冲区内容的修改强行写入文件；</li>
<li>load()：将缓冲区的内容载入内存，并返回该缓冲区的引用；</li>
<li>isLoaded()：如果缓冲区的内容在物理内存中，则返回真，否则返回假；</li>
</ul>
<h3 id="案例对比"><a href="#案例对比" class="headerlink" title="案例对比"></a>案例对比</h3><p>这里通过采用ByteBuffer和MappedByteBuffer分别读取大小约为5M的文件”src&#x2F;1.ppt”来比较两者之间的区别，method3()是采用MappedByteBuffer读取的，method4()对应的是ByteBuffer。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> method4()&#123;<br>    RandomAccessFile aFile = <span class="hljs-keyword">null</span>;<br>    FileChannel fc = <span class="hljs-keyword">null</span>;<br>    try&#123;<br>        aFile = <span class="hljs-built_in">new</span> RandomAccessFile(&quot;src/1.ppt&quot;,&quot;rw&quot;);<br>        fc = aFile.getChannel();<br>        long timeBegin = <span class="hljs-keyword">System</span>.currentTimeMillis();<br>        ByteBuffer buff = ByteBuffer.allocate((<span class="hljs-type">int</span>) aFile.length());<br>        buff.clear();<br>        fc.<span class="hljs-keyword">read</span>(buff);<br>        //<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println((<span class="hljs-type">char</span>)buff.<span class="hljs-keyword">get</span>((<span class="hljs-type">int</span>)(aFile.length()/<span class="hljs-number">2</span><span class="hljs-number">-1</span>)));<br>        //<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println((<span class="hljs-type">char</span>)buff.<span class="hljs-keyword">get</span>((<span class="hljs-type">int</span>)(aFile.length()/<span class="hljs-number">2</span>)));<br>        //<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println((<span class="hljs-type">char</span>)buff.<span class="hljs-keyword">get</span>((<span class="hljs-type">int</span>)(aFile.length()/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>));<br>        long timeEnd = <span class="hljs-keyword">System</span>.currentTimeMillis();<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Read time: &quot;+(timeEnd-timeBegin)+&quot;ms&quot;);<br>    &#125;catch(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;finally&#123;<br>        try&#123;<br>            <span class="hljs-keyword">if</span>(aFile!=<span class="hljs-keyword">null</span>)&#123;<br>                aFile.<span class="hljs-keyword">close</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(fc!=<span class="hljs-keyword">null</span>)&#123;<br>                fc.<span class="hljs-keyword">close</span>();<br>            &#125;<br>        &#125;catch(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> method3()&#123;<br>    RandomAccessFile aFile = <span class="hljs-keyword">null</span>;<br>    FileChannel fc = <span class="hljs-keyword">null</span>;<br>    try&#123;<br>        aFile = <span class="hljs-built_in">new</span> RandomAccessFile(&quot;src/1.ppt&quot;,&quot;rw&quot;);<br>        fc = aFile.getChannel();<br>        long timeBegin = <span class="hljs-keyword">System</span>.currentTimeMillis();<br>        MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, aFile.length());<br>        // <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println((<span class="hljs-type">char</span>)mbb.<span class="hljs-keyword">get</span>((<span class="hljs-type">int</span>)(aFile.length()/<span class="hljs-number">2</span><span class="hljs-number">-1</span>)));<br>        // <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println((<span class="hljs-type">char</span>)mbb.<span class="hljs-keyword">get</span>((<span class="hljs-type">int</span>)(aFile.length()/<span class="hljs-number">2</span>)));<br>        //<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println((<span class="hljs-type">char</span>)mbb.<span class="hljs-keyword">get</span>((<span class="hljs-type">int</span>)(aFile.length()/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>));<br>        long timeEnd = <span class="hljs-keyword">System</span>.currentTimeMillis();<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Read time: &quot;+(timeEnd-timeBegin)+&quot;ms&quot;);<br>    &#125;catch(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;finally&#123;<br>        try&#123;<br>            <span class="hljs-keyword">if</span>(aFile!=<span class="hljs-keyword">null</span>)&#123;<br>                aFile.<span class="hljs-keyword">close</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(fc!=<span class="hljs-keyword">null</span>)&#123;<br>                fc.<span class="hljs-keyword">close</span>();<br>            &#125;<br>        &#125;catch(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过在入口函数main()中运行：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">method3</span>();<br>System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;=============&quot;);<br><span class="hljs-built_in">method4</span>();<br></code></pre></td></tr></table></figure>

<p>输出结果（运行在普通PC机上）：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">Read time: 2ms</span><br><span class="hljs-section">=============</span><br>Read time: 12ms<br></code></pre></td></tr></table></figure>

<p>通过输出结果可以看出彼此的差别，一个例子也许是偶然，那么下面把5M大小的文件替换为200M的文件，输出结果：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">Read time: 1ms</span><br><span class="hljs-section">=============</span><br>Read time: 407ms<br></code></pre></td></tr></table></figure>

<p>可以看到差距拉大。</p>
<blockquote>
<p>注：MappedByteBuffer有资源释放的问题：被MappedByteBuffer打开的文件只有在垃圾收集时才会被关闭，而这个点是不确定的。在Javadoc中这里描述：A mapped byte buffer and the file mapping that it represents remian valid until the buffer itself is garbage-collected。详细可以翻阅参考资料5和6.</p>
</blockquote>
<hr>
<h2 id="六、其余功能介绍"><a href="#六、其余功能介绍" class="headerlink" title="六、其余功能介绍"></a>六、其余功能介绍</h2><p>看完以上陈述，详细大家对NIO有了一定的了解，下面主要通过几个案例，来说明NIO的其余功能，下面代码量偏多，功能性讲述偏少。</p>
<h3 id="Scatter-Gatter"><a href="#Scatter-Gatter" class="headerlink" title="Scatter&#x2F;Gatter"></a>Scatter&#x2F;Gatter</h3><p>分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</p>
<p>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。</p>
<p>scatter &#x2F; gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.Channel;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScattingAndGather</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        gather();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gather</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">header</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">byte</span> [] b1 = &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;;<br>        <span class="hljs-type">byte</span> [] b2 = &#123;<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;;<br>        header.put(b1);<br>        body.put(b2);<br>        ByteBuffer [] buffs = &#123;header, body&#125;;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;src/scattingAndGather.txt&quot;</span>);<br>            <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> os.getChannel();<br>            channel.write(buffs);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e)<br>        &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="transferFrom-transferTo"><a href="#transferFrom-transferTo" class="headerlink" title="transferFrom &amp; transferTo"></a>transferFrom &amp; transferTo</h3><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> method1()&#123;<br>    RandomAccessFile fromFile = <span class="hljs-keyword">null</span>;<br>    RandomAccessFile toFile = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        fromFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;src/fromFile.xml&quot;</span>,<span class="hljs-string">&quot;rw&quot;</span>);<br>        FileChannel fromChannel = fromFile.getChannel();<br>        toFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;src/toFile.txt&quot;</span>,<span class="hljs-string">&quot;rw&quot;</span>);<br>        FileChannel toChannel = toFile.getChannel();<br>        <span class="hljs-keyword">long</span> position = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = fromChannel.<span class="hljs-keyword">size</span>();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">count</span>);<br>        toChannel.transferFrom(fromChannel, position, <span class="hljs-keyword">count</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e)<br>    &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(fromFile != <span class="hljs-keyword">null</span>)&#123;<br>                fromFile.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(toFile != <span class="hljs-keyword">null</span>)&#123;<br>                toFile.close();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p>
<p>transferTo()方法将数据从FileChannel传输到其他的channel中。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> method2()<br>&#123;<br>    RandomAccessFile fromFile = <span class="hljs-keyword">null</span>;<br>    RandomAccessFile toFile = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        fromFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;src/fromFile.txt&quot;</span>,<span class="hljs-string">&quot;rw&quot;</span>);<br>        FileChannel fromChannel = fromFile.getChannel();<br>        toFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;src/toFile.txt&quot;</span>,<span class="hljs-string">&quot;rw&quot;</span>);<br>        FileChannel toChannel = toFile.getChannel();<br>        <span class="hljs-keyword">long</span> position = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = fromChannel.<span class="hljs-keyword">size</span>();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">count</span>);<br>        fromChannel.transferTo(position, <span class="hljs-keyword">count</span>,toChannel);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e)<br>    &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(fromFile != <span class="hljs-keyword">null</span>)&#123;<br>                fromFile.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(toFile != <span class="hljs-keyword">null</span>)&#123;<br>                toFile.close();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p>
<h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Pipe</span> <span class="hljs-variable">pipe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">try</span>&#123;<br>        pipe = Pipe.open();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Pipe</span> <span class="hljs-variable">pipeTemp</span> <span class="hljs-operator">=</span> pipe;<br>        exec.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Object&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception<br>            &#123;<br>                Pipe.<span class="hljs-type">SinkChannel</span> <span class="hljs-variable">sinkChannel</span> <span class="hljs-operator">=</span> pipeTemp.sink();<span class="hljs-comment">//向通道中写数据</span><br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">newData</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Pipe Test At Time &quot;</span>+System.currentTimeMillis();<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    buf.clear();<br>                    buf.put(newData.getBytes());<br>                    buf.flip();<br>                    <span class="hljs-keyword">while</span>(buf.hasRemaining())&#123;<br>                        System.out.println(buf);<br>                        sinkChannel.write(buf);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        exec.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Object&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception<br>            &#123;<br>                Pipe.<span class="hljs-type">SourceChannel</span> <span class="hljs-variable">sourceChannel</span> <span class="hljs-operator">=</span> pipeTemp.source();<span class="hljs-comment">//向通道中读数据</span><br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    buf.clear();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> sourceChannel.read(buf);<br>                    System.out.println(<span class="hljs-string">&quot;bytesRead=&quot;</span>+bytesRead);<br>                    <span class="hljs-keyword">while</span>(bytesRead &gt;<span class="hljs-number">0</span> )&#123;<br>                        buf.flip();<br>                        <span class="hljs-type">byte</span> b[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[bytesRead];<br>                        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">while</span>(buf.hasRemaining())&#123;<br>                            b[i]=buf.get();<br>                            System.out.printf(<span class="hljs-string">&quot;%X&quot;</span>,b[i]);<br>                            i++;<br>                        &#125;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b);<br>                        System.out.println(<span class="hljs-string">&quot;=================||&quot;</span>+s);<br>                        bytesRead = sourceChannel.read(buf);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        exec.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">reveive</span>()</span>&#123;<br>    DatagramChannel channel = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        channel = DatagramChannel.open();<br>        channel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        buf.clear();<br>        channel.receive(buf);<br>        buf.flip();<br>        <span class="hljs-keyword">while</span>(buf.hasRemaining())&#123;<br>            System.<span class="hljs-keyword">out</span>.print((<span class="hljs-built_in">char</span>)buf.<span class="hljs-keyword">get</span>());<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println();<br>    &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)&#123;<br>                channel.close();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span>()</span>&#123;<br>    DatagramChannel channel = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        channel = DatagramChannel.open();<br>        String info = <span class="hljs-string">&quot;I&#x27;m the Sender!&quot;</span>;<br>        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        buf.clear();<br>        buf.put(info.getBytes());<br>        buf.flip();<br>        <span class="hljs-built_in">int</span> bytesSent = channel.send(buf, <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;10.10.195.115&quot;</span>,<span class="hljs-number">8888</span>));<br>        System.<span class="hljs-keyword">out</span>.println(bytesSent);<br>    &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)&#123;<br>                channel.close();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<p>END</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java NIO</div>
      <div>https://leekosss.github.io/2022/09/24/Java-NIO/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>leekos</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月24日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2022年9月24日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/25/Spring-day1/" title="Spring-day1">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring-day1</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/18/Linux-v10-02%E5%A4%A9-%E6%8E%88%E8%AF%BE/" title="Linux-day02">
                        <span class="hidden-mobile">Linux-day02</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"e5J90iDkXMWhU5UNlEX1I2hO-gzGzoHsz","appKey":"esLROw9j3xLk2nV4tQkKaih1","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      赣ICP备2022008842号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
